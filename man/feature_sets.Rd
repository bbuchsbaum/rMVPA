% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_sets.R
\name{feature_sets}
\alias{feature_sets}
\title{Feature sets: grouped predictor matrices}
\usage{
feature_sets(x, spec = NULL, set_order = NULL, row_weights = NULL)
}
\arguments{
\item{x}{Either (1) a numeric matrix (observations x features) with a set spec,
or (2) a named list of numeric matrices, one per set (all with the same number
of rows), which will be column-bound in `set_order`.}

\item{spec}{A set spec as created by `blocks()` or `by_set()` (required when `x` is a matrix).}

\item{set_order}{Optional character vector giving the desired set order (defaults to
the order implied by `spec` or the names of the list).}

\item{row_weights}{Optional numeric vector of length nrow(X), used as observation weights
by downstream models (default: all 1).}
}
\value{
An object of class `feature_sets`.
}
\description{
Many rMVPA analyses use continuous predictors (rows = TRs/observations, columns
= stimulus features) to explain continuous neural responses (rows = TRs,
columns = voxels/parcels). In practice, stimulus predictors often come in
\emph{multiple correlated blocks} (e.g. VGG low/mid/high/semantic PCs, or audio
vs vision features), and it is useful to:
\itemize{
  \item regularize each block differently (banded/grouped ridge), and
  \item compute attribution/competition measures such as leave-one-set-out \eqn{\Delta R^2}.
}

Wrap a predictor representation into a `feature_sets` instance.
}
\details{
The `feature_sets()` constructor wraps a predictor matrix (or a list of per-set
matrices) into a `feature_sets` object that carries set labels and column
indices so that downstream models do not need to manually track slices.

You can supply predictors in two equivalent ways:
\enumerate{
  \item A single matrix \code{X} (observations x features) plus a set specification
        via `blocks()` or `by_set()`.
  \item A named list of matrices, one per set, each with the same number of rows.
        The matrices are column-bound in `set_order`.
}

The returned object includes:
\itemize{
  \item `X`: the concatenated numeric predictor matrix,
  \item `set`: a factor of length `ncol(X)` giving per-column set membership,
  \item `indices`: a named list mapping set name -> integer column indices,
  \item `dims`: number of columns per set,
  \item `row_weights`: optional observation weights (length `nrow(X)`).
}
}
\section{Feature set specifications}{

Use `blocks()` when your columns are already concatenated into consecutive blocks
(e.g. \code{[low|mid|high|sem]}). Use `by_set()` when you have a per-column set
label vector (non-contiguous groups).
}

\section{Row weights}{

A `feature_sets` object also stores `row_weights`. These are optional observation
weights (length = \code{nrow(X)}). They are primarily intended for soft-alignment
use cases where recall predictors are computed as \code{gamma \%*\% X_enc} and
the remaining posterior mass can be used to down-weight uncertain recall TRs
(see `expected_features()`).
}

\examples{
X <- matrix(rnorm(20 * 8), 20, 8)
fs <- feature_sets(X, blocks(low = 3, sem = 5))
fs
# 1) Matrix input + blocks()
X <- matrix(rnorm(20 * 8), 20, 8)
fs <- feature_sets(X, blocks(low = 3, sem = 5))

# 2) List input (already split per set)
Xlist <- list(low = X[, 1:3], sem = X[, 4:8])
fs2 <- feature_sets(Xlist)
}
\seealso{
\code{\link{blocks}}, \code{\link{by_set}}, \code{\link{feature_sets}},
  \code{\link{expected_features}}, \code{\link{feature_sets_design}},
  \code{\link{banded_ridge_da_model}}, \code{\link{grouped_ridge_da_model}},
  \code{\link{banded_ridge_da}}, \code{\link{grouped_ridge_da}}

\code{\link{blocks}}, \code{\link{by_set}}, \code{\link{expected_features}}
}
