% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/allgeneric.R, R/regional.R,
%   R/banded_ridge_da_model.R, R/feature_rsa_da_model.R
\name{run_regional}
\alias{run_regional}
\alias{run_regional_base}
\alias{run_regional.default}
\alias{run_regional.mvpa_model}
\alias{run_regional.rsa_model}
\alias{run_regional.vector_rsa_model}
\alias{run_regional.feature_rsa_model}
\alias{run_regional.banded_ridge_da_model}
\alias{run_regional.feature_rsa_da_model}
\title{Region of Interest Based MVPA Analysis}
\usage{
run_regional(
  model_spec,
  region_mask,
  backend = c("default", "shard", "auto"),
  ...
)

run_regional_base(
  model_spec,
  region_mask,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  compute_performance = model_spec$compute_performance,
  return_predictions = model_spec$return_predictions,
  return_fits = model_spec$return_fits,
  pool_predictions = c("none", "mean", "stack"),
  pooled_weights = NULL,
  stack_folds = NULL,
  stack_seed = NULL,
  stack_lambda = 0.001,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{default}(
  model_spec,
  region_mask,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{mvpa_model}(
  model_spec,
  region_mask,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{rsa_model}(
  model_spec,
  region_mask,
  return_fits = FALSE,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{vector_rsa_model}(
  model_spec,
  region_mask,
  return_fits = FALSE,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{feature_rsa_model}(
  model_spec,
  region_mask,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{banded_ridge_da_model}(
  model_spec,
  region_mask,
  return_fits = model_spec$return_fits,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)

\method{run_regional}{feature_rsa_da_model}(
  model_spec,
  region_mask,
  return_fits = model_spec$return_fits,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  backend = c("default", "shard", "auto"),
  ...
)
}
\arguments{
\item{model_spec}{A \code{mvpa_model} instance containing the model specifications}

\item{region_mask}{A \code{NeuroVol} or \code{NeuroSurface} object where each region is identified by a unique integer}

\item{backend}{Execution backend: \code{"default"} (standard pipeline),
\code{"shard"} (shared-memory backend), or \code{"auto"} (try shard and
fall back to default).}

\item{...}{Extra arguments passed to specific regional analysis methods (e.g., `return_fits`, `compute_performance`).}

\item{coalesce_design_vars}{If \code{TRUE}, merges design variables into the prediction table (if present and generated). Default is \code{FALSE}.}

\item{processor}{An optional custom processor function for each region (ROI). If NULL (default), behavior depends on the \code{model_spec} class.}

\item{verbose}{If \code{TRUE}, print progress messages during iteration (default is \code{FALSE}).}

\item{compute_performance}{Logical indicating whether to compute performance metrics (default \code{TRUE}).}

\item{return_predictions}{Logical indicating whether to combine a full prediction table (defaults to \code{model_spec$return_predictions}).}

\item{return_fits}{Logical indicating whether to return the fitted models (default \code{FALSE}).}

\item{pool_predictions}{Character scalar controlling pooled outputs:
\code{"none"} (default), \code{"mean"} (weighted mean pooling across ROIs),
or \code{"stack"} (cheap cross-fitted stacking on OOF ROI predictions).}

\item{pooled_weights}{Optional numeric vector of ROI weights used when
\code{pool_predictions = "mean"}. Must have one weight per ROI.}

\item{stack_folds}{Optional fold specification for stacking. Can be:
an integer number of folds, a fold-id vector, or a list of fold indices.}

\item{stack_seed}{Optional seed used when auto-generating stacking folds.}

\item{stack_lambda}{Ridge penalty used by \pkg{glmnet} in stacking.}
}
\value{
A \code{regional_mvpa_result} object (list) containing:
  \item{performance_table}{A tibble of performance metrics for each region (if computed).}
  \item{prediction_table}{A tibble with detailed predictions for each observation/region (if generated).}
  \item{pooled_prediction_table}{Optional pooled trial-level prediction table when pooling is requested.}
  \item{pooled_performance}{Optional pooled performance metrics when pooling is requested.}
  \item{vol_results}{A list of volumetric maps representing performance metrics across space (if computed).}
  \item{fits}{A list of fitted model objects for each region (if requested via `return_fits=TRUE`).}
  \item{model_spec}{The original model specification object provided.} # Note: Original documentation said 'performance', clarified here.
}
\description{
Run a separate MVPA analysis for multiple disjoint regions of interest.
}
\details{
This function serves as the base implementation for regional analyses, orchestrating data preparation, iteration over regions, performance computation, and result aggregation. Specific `run_regional` methods for different model classes may call this function or provide specialized behavior.

This is the fallback method called when no specialized `run_regional` method is found for the class of `model_spec`. It typically calls `run_regional_base`.

This method provides the standard regional analysis pipeline for objects of class `mvpa_model` by calling `run_regional_base`.

For `rsa_model` objects, `return_predictions` defaults to `FALSE` as standard RSA typically doesn't produce a prediction table in the same way as classification/regression models.

For `vector_rsa_model` objects, `return_predictions` defaults to `FALSE` in `run_regional_base`.
If `model_spec$return_predictions` is TRUE, this method will assemble an `observation_scores_table`.

For `feature_rsa_model` objects, `return_predictions` defaults to `FALSE`
  (set at model creation via `create_model_spec`). This method delegates to
  `run_regional_base`.
}
\examples{
\donttest{
  # Generate sample dataset (3D volume with categorical response)
  dataset <- gen_sample_dataset(
    D = c(10,10,10),       # Small 10x10x10 volume
    nobs = 100,            # 100 observations
    nlevels = 3,           # 3 classes
    response_type = "categorical",
    data_mode = "image",
    blocks = 3             # 3 blocks for cross-validation
  )
  
  # Create region mask with 5 ROIs
  region_mask <- neuroim2::NeuroVol(
    sample(1:5, size=length(dataset$dataset$mask), replace=TRUE),
    neuroim2::space(dataset$dataset$mask)
  )
  
  # Create cross-validation specification
  cval <- blocked_cross_validation(dataset$design$block_var)
  
  # Load SDA classifier (Shrinkage Discriminant Analysis)
  model <- load_model("sda_notune")
  
  # Create MVPA model
  mspec <- mvpa_model(
    model = model,
    dataset = dataset$dataset,
    design = dataset$design,
    model_type = "classification",
    crossval = cval,
    return_fits = TRUE    # Return fitted models
  )
  
  # Run regional analysis
  results <- run_regional(mspec, region_mask)
  
  # Access results
  head(results$performance_table)     # Performance metrics
  head(results$prediction_table)      # Predictions
  first_roi_fit <- results$fits[[1]]  # First ROI's fitted model
}

}
