% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/banded_ridge_da_model.R
\name{banded_ridge_da_model}
\alias{banded_ridge_da_model}
\alias{grouped_ridge_da_model}
\title{Grouped (banded) ridge domain-adaptation model (continuous predictors -> brain)}
\usage{
banded_ridge_da_model(
  dataset,
  design,
  mode = c("stacked", "coupled"),
  lambdas,
  alpha_recall = 0.2,
  alpha_target = NULL,
  rho = 5,
  recall_folds = NULL,
  target_folds = NULL,
  recall_nfolds = 5L,
  target_nfolds = NULL,
  compute_delta_r2 = TRUE,
  delta_sets = NULL,
  return_diagnostics = FALSE,
  ...
)

grouped_ridge_da_model(
  dataset,
  design,
  mode = c("stacked", "coupled"),
  lambdas,
  alpha_recall = 0.2,
  alpha_target = NULL,
  rho = 5,
  recall_folds = NULL,
  target_folds = NULL,
  recall_nfolds = 5L,
  target_nfolds = NULL,
  compute_delta_r2 = TRUE,
  delta_sets = NULL,
  return_diagnostics = FALSE,
  ...
)
}
\arguments{
\item{dataset}{An `mvpa_dataset` with `train_data` (train/source) and `test_data` (test/target).}

\item{design}{A `feature_sets_design` created by `feature_sets_design()`.}

\item{mode}{`"stacked"` or `"coupled"`.}

\item{lambdas}{Named numeric vector of ridge penalties per feature set.
Names must match `names(design$X_train$indices)`.}

\item{alpha_recall}{Non-negative scalar weighting the test/target loss (default 0.2).
This argument is kept for backward compatibility with the original encoding/recall use case.}

\item{alpha_target}{Optional non-negative scalar weighting the test/target loss.
If provided, overrides `alpha_recall`.}

\item{rho}{Non-negative scalar coupling strength (only used when `mode="coupled"`).}

\item{recall_folds}{Optional explicit list of folds, each a list with `train` and `test`
integer indices over test rows. If NULL, folds are derived from `design$block_var_test`
when available; otherwise, contiguous K-fold splits are used.}

\item{target_folds}{Optional explicit folds over test rows. If provided, overrides `recall_folds`.}

\item{recall_nfolds}{Integer number of contiguous folds to use when only one test block is present.}

\item{target_nfolds}{Integer number of contiguous folds to use when only one test block is present.
If provided, overrides `recall_nfolds`.}

\item{compute_delta_r2}{Logical; if TRUE, compute leave-one-set-out unique contribution
\eqn{\Delta R^2} on held-out test (default TRUE).}

\item{delta_sets}{Optional character vector of set names to compute \eqn{\Delta R^2} for
(default: all sets).}

\item{return_diagnostics}{Logical; if TRUE, store fold-level diagnostics (fold definitions,
per-fold R-squared/MSE, hyperparameters) in `regional_mvpa_result$fits` when running
`run_regional()` (default FALSE).}

\item{...}{Additional arguments (currently unused).}
}
\value{
A model spec of class `banded_ridge_da_model` compatible with `run_regional()` and `run_searchlight()`.

A model spec of class `banded_ridge_da_model` compatible with `run_regional()` and `run_searchlight()`.
}
\description{
Fit multivariate linear models from continuous predictors (TR x features)
to ROI/searchlight activity (TR x voxels), with predictors organized into named
\emph{feature sets}. This supports both:
\itemize{
  \item \strong{domain adaptation}: allow or enforce similarity between train/source and test/target mappings, and
  \item \strong{feature-set competition}: quantify what each feature set adds beyond the others.
}

Preferred name for `banded_ridge_da_model()`. See that function for full details.
}
\details{
\strong{Data model.}
For each ROI/searchlight, rMVPA provides:
\itemize{
  \item Train/source responses \eqn{Y_{train}} from `dataset$train_data` (rows = TRs, columns = voxels).
  \item Test/target responses \eqn{Y_{test}} from `dataset$test_data` (rows = TRs, columns = voxels).
}
Predictors are stored on a `feature_sets_design`:
\itemize{
  \item Train/source predictors \eqn{X_{train}} in `design$X_train$X`.
  \item Test/target predictors \eqn{X_{test}} in `design$X_test$X`.
}

\strong{Grouped (banded) ridge.}
Each predictor column belongs to a named feature set (e.g. low/mid/high/sem). The
ridge penalty is applied per-column based on that set, i.e. a diagonal penalty
\eqn{P} where entries for columns in set \eqn{g} take value \eqn{\lambda_g}.

\strong{Two training modes.}
\itemize{
  \item \emph{stacked}: fit a single \eqn{\beta} by stacking train and test rows
        (with test down-weighted by `alpha_recall`/`alpha_target` and optional test TR weights from `design$X_test$row_weights`).
  \item \emph{coupled}: fit \eqn{\beta_{train}} and \eqn{\beta_{test}} with coupling strength `rho`,
        allowing a controlled train->test shift while still borrowing strength across domains.
}

\strong{Test/target-time cross-validation (default).}
If test blocks/runs are provided (`design$block_var_test`) and there are at least two
unique blocks, evaluation uses leave-one-block-out on test time. If only one block
is present, evaluation falls back to contiguous folds over test TRs (`recall_nfolds`/`target_nfolds`).
In all cases, \emph{all train TRs are always included in training} for each fold.
This avoids transductive evaluation when test data are used in training.

\strong{Feature-set attribution via} \eqn{\Delta R^2}.
When `compute_delta_r2 = TRUE`, the model computes leave-one-set-out unique contribution
on held-out test:
\deqn{\Delta R^2_g = R^2_{\mathrm{full}} - R^2_{-g},}
where \eqn{R^2_{-g}} is obtained by refitting the model without feature set \eqn{g}.
}
\examples{
\dontrun{
# Build encoding predictors and declare feature sets
fs_enc <- feature_sets(X_enc, blocks(low = 100, mid = 100, high = 100, sem = 100))

# Build recall predictors from a soft alignment posterior gamma
fs_rec <- expected_features(fs_enc, gamma, drop_null = TRUE, renormalize = FALSE)

# Create design and model spec
des <- feature_sets_design(fs_enc, fs_rec, block_var_test = recall_runs)
ms <- grouped_ridge_da_model(
  dataset = dset,
  design = des,
  mode = "coupled",
  lambdas = c(low = 10, mid = 10, high = 10, sem = 10),
  alpha_recall = 0.2,
  rho = 5,
  compute_delta_r2 = TRUE,
  return_diagnostics = TRUE
)

res <- run_regional(ms, region_mask)
}
}
\seealso{
\code{\link{feature_sets}}, \code{\link{expected_features}}, \code{\link{feature_sets_design}},
  \code{\link{banded_ridge_da}}, \code{\link{grouped_ridge_da}}
}
