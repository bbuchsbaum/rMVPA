% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hrfdecoder_model.R
\name{hrfdecoder_model}
\alias{hrfdecoder_model}
\title{hrfdecoder Model (continuous-time MVPA)}
\usage{
hrfdecoder_model(
  dataset,
  design,
  lambda_W = 10,
  lambda_HRF = 1,
  lambda_smooth = 5,
  basis = NULL,
  window = c(4, 8),
  nonneg = TRUE,
  max_iter = 10,
  tol = 1e-04,
  performance = NULL,
  crossval = NULL,
  return_predictions = TRUE,
  return_fits = FALSE,
  metrics = c("auc_ovo", "accuracy"),
  primary_metric = "auc_ovo"
)
}
\arguments{
\item{dataset}{An `mvpa_dataset` with continuous TR x V data and mask.}

\item{design}{An `hrfdecoder_design` (subclass of `mvpa_design`) created by
`hrfdecoder_design(event_model, events, block_var, ...)`.}

\item{lambda_W}{Decoder ridge penalty (default: 10). Controls regularization of
decoder weights to prevent overfitting.}

\item{lambda_HRF}{Weight for HRF-conformity of soft labels (default: 1). Higher
values force soft labels closer to the HRF-convolved event design.}

\item{lambda_smooth}{Temporal smoothness penalty for soft labels (default: 5).
Penalizes rapid changes in soft labels between adjacent TRs.}

\item{basis}{Optional HRF basis (e.g., fmrihrf::spmg1()). If NULL, uses the hrfdecoder default.}

\item{window}{Numeric length-2 (start,end) seconds after onset for event aggregation
(default: c(4, 8)). Defines the time window for aggregating TR-level predictions
to event-level.}

\item{nonneg}{Logical; whether to project soft labels to non-negative (default: TRUE).}

\item{max_iter}{Integer; maximum ALS iterations (default: 10).}

\item{tol}{Convergence tolerance (default: 1e-4).}

\item{performance}{Optional custom performance function that takes a classification_result.}

\item{crossval}{Optional cross-validation spec. If NULL and `design$block_var` exists, uses blocked CV.}

\item{return_predictions}{Logical; keep per-fold aggregated event predictions (default: TRUE).}

\item{return_fits}{Logical; keep per-fold fit objects (default: FALSE).}

\item{metrics}{Character vector of fast metrics to compute on event-level probs
when available (via hrfdecoder::hrf_metrics). Examples: c("auc_ovo","accuracy").
These are added non-invasively to the result row and do not affect the
legacy rMVPA performance vector.}

\item{primary_metric}{Optional character naming which metric to surface as
the primary summary (stored as `primary_metric` and `primary_value` in ROI
outputs). Defaults to "auc_ovo" if available.}
}
\value{
An S3 model spec object of class `hrfdecoder_model` compatible with run_searchlight.
}
\description{
Adapter model that trains a continuous-time decoder on TR-level data within each
ROI/fold and aggregates to event-level predictions. This model integrates with
existing rMVPA searchlight/cross-validation iterators and delegates the core
solver to the external 'hrfdecoder' package.
}
\details{
The hrfdecoder approach differs from traditional MVPA by operating directly on
continuous TR-level data without requiring trial-level beta estimation. It jointly
estimates decoder weights (W), TR-level soft labels (P), and HRF parameters via
an alternating least squares optimization that incorporates temporal smoothness
and HRF conformity penalties.

Usage notes:
- Requires the 'hrfdecoder' package at runtime; we check via requireNamespace.
- Use the explicit `hrfdecoder_design()` constructor (subclasses `mvpa_design`).
  This keeps event metadata explicit without adding ad-hoc members to a plain design.
- Cross-validation operates at the TR level (typically blocked by run), but
  performance metrics are computed on event-level predictions after aggregation.
}
\examples{
\dontrun{
library(fmridesign)
library(fmrihrf)
library(hrfdecoder)

# 1. Create event table
events_df <- data.frame(
  onset = seq(10, 290, by = 20),  # Events every 20 seconds
  condition = rep(c("A", "B", "C"), length.out = 15),
  run = rep(1:3, each = 5)
)

# 2. Define temporal structure
sframe <- sampling_frame(blocklens = c(100, 100, 100), TR = 2)

# 3. Build event model
evmod <- event_model(
  onset ~ hrf(condition, basis = "spmg3"),
  data = events_df,
  block = ~run,
  sampling_frame = sframe
)

# 4. Create rMVPA dataset
mask <- neuroim2::NeuroVol(...)
fmri_data <- neuroim2::NeuroVec(...)  # 300 TRs
dset <- mvpa_dataset(train_data = fmri_data, mask = mask)

# 5. Create hrfdecoder design
block_var <- rep(1:3, each = 100)
design <- hrfdecoder_design(
  event_model = evmod,
  events = events_df,
  block_var = block_var
)

# 6. Specify model with custom hyperparameters
mspec <- hrfdecoder_model(
  dataset = dset,
  design = design,
  lambda_W = 10,
  lambda_HRF = 1,
  lambda_smooth = 5,
  basis = fmrihrf::spmg1(),
  window = c(4, 8),
  max_iter = 15
)

# 7. Run searchlight analysis
results <- run_searchlight(mspec, radius = 8, method = "randomized", niter = 4)
}
}
