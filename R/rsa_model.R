#' @noRd
#' @keywords internal
sanitize <- function(name) {
  name <- gsub(":", ".", name)
  name <- gsub(" ", "", name)
  name <- gsub("[\\(\\)]", ".", name, perl=TRUE)
  name <- gsub(",", "_", name)
  name <- gsub("\\.$", "", name)
  name
}


#' Construct a design for an RSA (Representational Similarity Analysis) model
#'
#' This function constructs a design for an RSA model using the provided formula, data, and optional parameters.
#'
#' @param formula A formula expression specifying the dissimilarity-based regression function.
#' @param data A named list containing the dissimilarity matrices and any other auxiliary variables.
#' @param block_var An optional \code{formula}, \code{character} name or \code{integer} vector designating the block structure.
#' @param split_by An optional \code{formula} indicating grouping structure for evaluating test performance.
#' @param keep_intra_run A \code{logical} indicating whether to include within-run comparisons (default: FALSE).
#' @return A list with class attributes "rsa_design" and "list", containing:
#'   \describe{
#'     \item{formula}{The input formula}
#'     \item{data}{The input data}
#'     \item{split_by}{The split_by formula}
#'     \item{split_groups}{Grouping structure for split_by}
#'     \item{block_var}{Block structure}
#'     \item{include}{Logical vector for including/excluding comparisons}
#'     \item{model_mat}{Model matrix generated by rsa_model_mat}
#'   }
#' @details
#' The function creates an RSA design based on the input parameters. It checks the validity of the input data and
#' handles splitting conditions for evaluation of test performance. It also processes optional block structures and
#' within-run comparisons.
#' @importFrom assertthat assert_that
#' @export
#' @examples
#' dismat <- dist(matrix(rnorm(100*100), 100, 100))
#' rdes <- rsa_design(~ dismat, list(dismat=dismat))
rsa_design <- function(formula, data, block_var=NULL, split_by=NULL, keep_intra_run=FALSE) {
  assert_that(purrr::is_formula(formula))
  
  # Check that all variables are either matrices, "dist", or vectors
  nr <- sapply(data, function(x) {
    if (is.matrix(x)) {
      nrow(x)
    } else if (inherits(x, "dist")) {
      attr(x, "Size")
    } else if (is.vector(x)) {
      length(x)
    } else {
      stop(paste("illegal variable type", class(x)))
    }
  })
  
  assert_that(all(nr == nr[1]), msg="all elements in 'data' must have the same number of rows")
  
  check_split <- function(split_var) {
    minSplits <- min(table(split_var))
    if (minSplits < 3) {
      stop(paste("error: splitting condition results in fewer than 3 observations in at least one set"))
    }
  }
  
  # Create split groups if split_by is provided
  split_groups <- if (!is.null(split_by)) {
    split_var <- parse_variable(split_by, data)
    split(seq_along(split_var), split_var)
  }
  
  # Process block_var if provided
  block_var <- if (!is.null(block_var)) {
    parse_variable(block_var, data)
  }
  
  # Include/exclude within-run comparisons based on keep_intra_run
  include <- if (!is.null(block_var) && !keep_intra_run) {
    as.vector(dist(block_var)) != 0
  }
  
  # Create the RSA design as a list
  des <- list(
    formula=formula,
    data=data,
    split_by=split_by,
    split_groups=split_groups,
    block_var=block_var,
    include=include
  )
  
  # Add model matrix to the design list
  mmat <- rsa_model_mat(des)
  des$model_mat <- mmat
  
  # Set the class attributes
  class(des) <- c("rsa_design", "list")
  
  # Return the RSA design
  des
}


#' Construct a model matrix for an RSA (Representational Similarity Analysis) design
#'
#' This function constructs a model matrix for the given RSA design by processing distance matrices and other variables.
#'
#' @param rsa_des An RSA design object created by \code{rsa_design()}, containing formula, data, and optional parameters.
#' @return A named list of vectors, where:
#'   \itemize{
#'     \item Names correspond to sanitized variable names from the formula
#'     \item Each vector is the processed version of the corresponding input data
#'     \item For distance matrices, only the lower triangle is included
#'     \item If rsa_des$include is specified, vectors are subset accordingly
#'   }
#' @details
#' The function takes an RSA design object as input and processes the distance matrices and other variables to
#' construct a model matrix. It handles different types of input matrices, including symmetric and asymmetric
#' distance matrices, and can include or exclude within-run comparisons based on the RSA design.
#' @examples
#' dismat <- dist(matrix(rnorm(100*100), 100, 100))
#' rdes <- rsa_design(~ dismat, list(dismat=dismat))
#' rsa_model_mat(rdes)
#' @keywords internal
#' @noRd
rsa_model_mat <- function(rsa_des) {
  rvars <- labels(terms(rsa_des$formula))
  denv <- list2env(rsa_des$data)
  vset <- lapply(rvars, function(x) eval(parse(text=x), envir=denv))
  
  # Process input variables to create vectors from distance matrices
  vmatlist <- lapply(vset, function(v) {
    if (inherits(v, "dist")) {
      as.vector(v)  # class "dist"
    } else if (isSymmetric(v)) {
      v[lower.tri(v)]
    } else {
      as.vector(dist(v))
    }
  })
  
  # Include or exclude within-run comparisons based on rsa_des$include
  if (!is.null(rsa_des$include)) {
    vmatlist <- lapply(vmatlist, function(v) v[rsa_des$include])
  }
  
  # Assign sanitized names
  names(vmatlist) <- sanitize(rvars)
  
  # Return the model matrix as a named list of vectors
  vmatlist
}


#' @keywords internal
#' @importFrom Rfit rfit
#' @noRd
run_rfit <- function(dvec, obj) {
  form <- paste("dvec", "~", paste(names(obj$design$model_mat), collapse = " + "))
  obj$design$model_mat$dvec <- dvec
  res <- Rfit::rfit(form, data=obj$design$model_mat)
  coef(res)[-1]
}


#' @keywords internal
#' @importFrom stats coef cor dist rnorm terms lm sd
#' @noRd
check_collinearity <- function(model_mat) {
  # Get the design matrix and names
  vnames <- names(model_mat)
  design_matrix <- as.matrix(model_mat)
  
  # Basic check - need at least 2 columns for collinearity
  if (ncol(design_matrix) > 1) {
    # Calculate correlation matrix and check for high correlations
    tryCatch({
      cor_matrix <- cor(design_matrix, use = "pairwise.complete.obs")
      diag(cor_matrix) <- 0
      if (any(abs(cor_matrix) > 0.99, na.rm = TRUE)) {
        high_cor_pairs <- which(abs(cor_matrix) > 0.99, arr.ind = TRUE)
        if (nrow(high_cor_pairs) > 0) {
          problem_vars <- apply(high_cor_pairs, 1, function(idx) {
            paste(vnames[c(idx[1], idx[2])], collapse = " and ")
          })
          stop(sprintf("Collinearity detected among predictors: %s. Consider removing one of the correlated variables.",
                       paste(problem_vars, collapse = "; ")))
        }
      }
      
      # Also check linear dependencies using QR decomposition
      qr_result <- qr(design_matrix)
      if (qr_result$rank < ncol(design_matrix)) {
        stop(sprintf("Design matrix is rank deficient (rank %d < %d columns). Some predictors are linear combinations of others.", 
                     qr_result$rank, ncol(design_matrix)))
      }
    }, error = function(e) {
      if (grepl("NA/NaN/Inf", e$message)) {
        stop("Cannot compute correlations due to NA/NaN/Inf values in predictor variables.")
      } else {
        stop(paste("Error checking collinearity:", e$message))
      }
    })
  }
}


#' @keywords internal
#' @importFrom stats coef cor dist rnorm terms lm sd
#' @noRd
run_lm <- function(dvec, obj) {
  # This is the standard LM approach that returns T-values for each predictor.
  form <- paste("dvec", "~", paste(names(obj$design$model_mat), collapse = " + "))
  vnames <- names(obj$design$model_mat)
  obj$design$model_mat$dvec <- dvec
  
  fit <- lm(form, data=obj$design$model_mat)
  # Return T-values (3rd column of coef summary)
  tvals <- coef(summary(fit))[-1, 3]
  names(tvals) <- vnames
  tvals
}


#' @keywords internal
#' @noRd
run_cor <- function(dvec, obj) {
  # For 'pearson' or 'spearman' regtype, we just do correlation with each predictor
  res <- sapply(obj$design$model_mat, function(x) cor(dvec, x, method=obj$distmethod))
  names(res) <- names(obj$design$model_mat)
  res
}


################################################################################
# NEW: Constrained LM with glmnet
################################################################################
#' @keywords internal
#' @importFrom glmnet glmnet
#' @noRd
run_lm_constrained <- function(dvec, obj) {
  # Check if glmnet is available and install if needed
  if (!requireNamespace("glmnet", quietly = TRUE)) {
    stop("Package 'glmnet' is required for non-negative constraints. Please install it with: install.packages('glmnet')")
  }
  
  # Convert list of vectors (predictors) into a matrix
  var_names <- names(obj$design$model_mat)
  X <- do.call(cbind, obj$design$model_mat)  # columns = predictors
  colnames(X) <- var_names
  
  # Identify which predictors should be constrained to be >= 0
  if (is.null(obj$nneg)) {
    stop("run_lm_constrained called, but obj$nneg is NULL.")
  }
  
  nneg_names <- names(obj$nneg)
  lower_lim_vec <- sapply(var_names, function(vn) {
    if (vn %in% nneg_names) 0 else -Inf
  })
  
  # Create penalty_factor vector - add a small penalty to non-negative terms
  # and zero penalty to unconstrained terms to avoid the "all penalty factors <= 0" error
  penalty_factor <- sapply(var_names, function(vn) {
    if (vn %in% nneg_names) 1e-5 else 0
  })
  
  # Use a small alpha (mixing parameter) to ensure stability
  alpha_val <- 1e-5
  
  # Fit glmnet with near-zero lambda and minimal penalty on non-negative variables
  fit <- tryCatch({
    glmnet::glmnet(
      x = X,
      y = dvec,
      alpha = alpha_val,                       
      lambda = 1e-5,                  
      penalty.factor = penalty_factor,
      lower.limits = lower_lim_vec,
      standardize = FALSE,
      intercept = TRUE
    )
  }, error = function(e) {
    # If error still occurs, try a different approach with all penalty factors = 1
    warning("First glmnet attempt failed, trying with uniform penalties: ", e$message)
    glmnet::glmnet(
      x = X,
      y = dvec,
      alpha = alpha_val,
      lambda = 1e-5,
      lower.limits = lower_lim_vec,
      standardize = FALSE,
      intercept = TRUE
    )
  })
  
  # Extract coefficients at smallest lambda
  lambda_min <- min(fit$lambda)
  
  # Properly extract coefficients - coef is S3 method
  coef_matrix <- predict(fit, type = "coefficients", s = lambda_min)
  # First row is intercept, we want rows 2:end
  betas <- as.numeric(coef_matrix)[-1]
  names(betas) <- var_names
  
  betas
}


################################################################################
# NEW: Semi-Partial LM
################################################################################
#' @keywords internal
#' @noRd
run_lm_semipartial <- function(dvec, obj) {
  # Compute semi-partial correlations from a single LM fit
  # sr_i = sign(t_i) * sqrt( (t_i^2 * MSE) / TSS )
  
  form <- paste("dvec", "~", paste(names(obj$design$model_mat), collapse = " + "))
  vnames <- names(obj$design$model_mat)
  obj$design$model_mat$dvec <- dvec
  
  fit  <- lm(form, data=obj$design$model_mat)
  smry <- summary(fit)
  
  # t-values (excluding intercept)
  tvals <- coef(smry)[-1, 3]
  
  # Residual MSE
  MSE <- smry$sigma^2
  
  # TSS = total sum of squares of the outcome
  y_mod <- fit$model$dvec
  TSS   <- sum((y_mod - mean(y_mod))^2)
  
  # Compute sr_i
  sr2 <- (tvals^2 * MSE) / TSS
  sr  <- sign(tvals) * sqrt(sr2)
  
  names(sr) <- vnames
  sr
}


################################################################################
# TRAINING METHOD
################################################################################
#' Train an RSA Model
#'
#' This function trains an RSA (representational similarity analysis) model using the specified method and distance calculation.
#'
#' @param obj An object of class \code{rsa_model}.
#' @param train_dat The training data.
#' @param y The response variable.
#' @param indices The indices of the training data.
#' @param ... Additional arguments passed to the training method.
#' @return 
#' Depending on \code{obj$regtype}:
#' \itemize{
#'   \item \code{"lm"} + no constraints + \code{obj$semipartial=TRUE}: semi-partial correlations
#'   \item \code{"lm"} + no constraints + \code{obj$semipartial=FALSE}: T-values of each predictor
#'   \item \code{"lm"} + \code{nneg} constraints: raw coefficients from constrained \code{glmnet}
#'   \item \code{"rfit"}: robust regression coefficients
#'   \item \code{"pearson"} or \code{"spearman"}: correlation coefficients
#' }
#' @export
train_model.rsa_model <- function(obj, train_dat, y, indices, ...) {
  # 1) correlation-based distance
  dtrain <- 1 - cor(t(train_dat), method=obj$distmethod)
  dvec   <- dtrain[lower.tri(dtrain)]
  
  # 2) Exclude certain comparisons if needed
  if (!is.null(obj$design$include)) {
    dvec <- dvec[obj$design$include]
  }
  
  # 3) Switch on regtype + constraints + semipartial
  out <- switch(
    obj$regtype,
    
    # robust regression
    rfit = run_rfit(dvec, obj),
    
    # linear model
    lm = {
      has_nneg <- (!is.null(obj$nneg) && length(obj$nneg) > 0)
      
      if (has_nneg) {
        # Use constrained approach
        run_lm_constrained(dvec, obj)
      } else if (isTRUE(obj$semipartial)) {
        # Semi-partial correlations
        run_lm_semipartial(dvec, obj)
      } else {
        # Standard approach = t-values
        run_lm(dvec, obj)
      }
    },
    
    # correlation-based
    pearson  = run_cor(dvec, obj),
    spearman = run_cor(dvec, obj)
  )
  
  out
}


################################################################################
# PRINT METHODS
################################################################################
#' @export
#' @method print rsa_model
print.rsa_model <- function(x, ...) {
  # Ensure crayon is available
  if (!requireNamespace("crayon", quietly = TRUE)) {
    stop("Package 'crayon' is required for pretty printing. Please install it.")
  }
  
  # Color scheme
  header_style  <- crayon::bold$cyan
  section_style <- crayon::yellow
  info_style    <- crayon::white
  number_style  <- crayon::green
  method_style  <- crayon::magenta
  formula_style <- crayon::italic$blue
  
  # Print header
  cat("\n", header_style("█▀▀ RSA Model ▀▀█"), "\n\n")
  
  # Model configuration
  cat(section_style("├─ Configuration"), "\n")
  cat(info_style("│  ├─ Distance Method: "), method_style(x$distmethod), "\n")
  cat(info_style("│  └─ Regression Type: "), method_style(x$regtype), "\n")
  
  # If nonneg constraints are present
  if (!is.null(x$nneg) && length(x$nneg) > 0) {
    cat(info_style("│  └─ Non-negativity on: "),
        method_style(paste(names(x$nneg), collapse=", ")), "\n")
  }
  
  # If semipartial
  if (isTRUE(x$semipartial) && (is.null(x$nneg) || length(x$nneg) == 0)) {
    cat(info_style("│  └─ Semi-partial: "), method_style("TRUE"), "\n")
  }
  
  # Dataset info
  cat(section_style("├─ Dataset"), "\n")
  dims <- dim(x$dataset$train_data)
  dim_str <- paste0(
    paste(dims[-length(dims)], collapse=" × "), 
    " × ", number_style(dims[length(dims)]), " observations"
  )
  cat(info_style("│  ├─ Dimensions: "), dim_str, "\n")
  cat(info_style("│  └─ Type: "), class(x$dataset$train_data)[1], "\n")
  
  # Design info
  cat(section_style("├─ Design"), "\n")
  cat(info_style("│  ├─ Formula: "), formula_style(deparse(x$design$formula)), "\n")
  
  var_names <- names(x$design$model_mat)
  cat(info_style("│  └─ Predictors: "), method_style(paste(var_names, collapse=", ")), "\n")
  
  # Structure info
  cat(section_style("└─ Structure"), "\n")
  
  # Block info
  if (!is.null(x$design$block_var)) {
    blocks <- table(x$design$block_var)
    cat(info_style("   ├─ Blocking: "), "Present\n")
    cat(info_style("   ├─ Number of Blocks: "), number_style(length(blocks)), "\n")
    cat(info_style("   ├─ Mean Block Size: "), 
        number_style(format(mean(blocks), digits=2)),
        crayon::italic$white(" (SD: "),
        number_style(format(sd(blocks), digits=2)),
        crayon::italic$white(")"), "\n")
  } else {
    cat(info_style("   ├─ Blocking: "), crayon::red("None"), "\n")
  }
  
  # Split info
  if (!is.null(x$design$split_by)) {
    split_info <- length(x$design$split_groups)
    cat(info_style("   └─ Split Groups: "), number_style(split_info), "\n")
  } else {
    cat(info_style("   └─ Split Groups: "), crayon::red("None"), "\n")
  }
  
  cat("\n")
}


#' @export
#' @method print rsa_design
print.rsa_design <- function(x, ...) {
  # Ensure crayon is available
  if (!requireNamespace("crayon", quietly = TRUE)) {
    stop("Package 'crayon' is required for pretty printing. Please install it.")
  }
  
  # Color scheme
  header_style  <- crayon::bold$cyan
  section_style <- crayon::yellow
  info_style    <- crayon::white
  number_style  <- crayon::green
  formula_style <- crayon::italic$blue
  var_style     <- crayon::magenta
  
  # Print header
  cat("\n", header_style("█▀▀ RSA Design ▀▀█"), "\n\n")
  
  # Formula
  cat(section_style("├─ Formula"), "\n")
  cat(info_style("│  └─ "), formula_style(deparse(x$formula)), "\n")
  
  # Variables
  cat(section_style("├─ Variables"), "\n")
  var_types <- sapply(x$data, function(v) {
    if (inherits(v, "dist")) "distance matrix"
    else if (is.matrix(v)) "matrix"
    else if (is.vector(v)) "vector"
    else "other"
  })
  
  cat(info_style("│  ├─ Total Variables: "), number_style(length(x$data)), "\n")
  for (i in seq_along(x$data)) {
    prefix <- if (i == length(x$data)) "└" else "├"
    cat(info_style(sprintf("│  %s─ ", prefix)), 
        var_style(names(x$data)[i]), ": ", 
        number_style(var_types[i]), "\n")
  }
  
  # Structure
  cat(section_style("└─ Structure"), "\n")
  
  # Block info
  if (!is.null(x$block_var)) {
    blocks <- table(x$block_var)
    cat(info_style("   ├─ Blocking: "), "Present\n")
    cat(info_style("   ├─ Number of Blocks: "), number_style(length(blocks)), "\n")
    cat(info_style("   ├─ Block Sizes: "), 
        number_style(paste0(names(blocks), ": ", blocks, collapse=", ")), "\n")
  } else {
    cat(info_style("   ├─ Blocking: "), crayon::red("None"), "\n")
  }
  
  # Include/exclude info
  if (!is.null(x$include)) {
    n_comparisons <- length(x$include)
    n_included <- sum(x$include)
    cat(info_style("   └─ Comparisons: "), 
        number_style(n_included), 
        crayon::italic$white(" of "), 
        number_style(n_comparisons), 
        crayon::italic$white(sprintf(" (%.1f%%)", 100*n_included/n_comparisons)), "\n")
  } else {
    cat(info_style("   └─ Comparisons: "), "All included\n")
  }
  
  cat("\n")
}


#' Construct an RSA (Representational Similarity Analysis) model
#'
#' This function creates an RSA model object by taking an MVPA (Multi-Variate Pattern Analysis) dataset and an RSA design.
#'
#' @param dataset An instance of an \code{mvpa_dataset}.
#' @param design An instance of an \code{rsa_design} created by \code{rsa_design()}.
#' @param distmethod A character string specifying the method used to compute distances between observations. 
#'        One of: \code{"pearson"} or \code{"spearman"} (defaults to "spearman").
#' @param regtype A character string specifying the analysis method. 
#'        One of: \code{"pearson"}, \code{"spearman"}, \code{"lm"}, or \code{"rfit"} (defaults to "pearson").
#' @param check_collinearity Logical indicating whether to check for collinearity in the design matrix. 
#'        Only applies when \code{regtype="lm"}. Default is TRUE.
#' @param nneg A named list of variables (predictors) for which non-negative regression coefficients should be enforced 
#'        (only if \code{regtype="lm"}). Defaults to \code{NULL} (no constraints).
#' @param semipartial Logical indicating whether to compute semi-partial correlations in the \code{"lm"} case 
#'        (only if \code{nneg} is not used). Defaults to \code{FALSE}.
#'
#' @return An object of class \code{"rsa_model"} (and \code{"list"}), containing:
#' \itemize{
#'   \item \code{dataset}    : the input dataset
#'   \item \code{design}     : the RSA design
#'   \item \code{distmethod} : the distance method used
#'   \item \code{regtype}    : the regression type
#'   \item \code{nneg}       : a named list of constrained variables, if any
#'   \item \code{semipartial}: whether to compute semi-partial correlations
#' }
#' @examples
#' # Create a random MVPA dataset
#' data <- matrix(rnorm(100 * 100), 100, 100)
#' labels <- factor(rep(1:2, each = 50))
#' mvpa_data <- mvpa_dataset(data, labels)
#'
#' # Create an RSA design with two distance matrices
#' dismat1 <- dist(data)
#' dismat2 <- dist(matrix(rnorm(100*100), 100, 100))
#' rdes <- rsa_design(~ dismat1 + dismat2, list(dismat1=dismat1, dismat2=dismat2))
#'
#' # Create an RSA model with standard 'lm' (returns t-values):
#' rsa_mod <- rsa_model(mvpa_data, rdes, regtype="lm")
#'
#' # Create an RSA model enforcing non-negativity for dismat2 only:
#' # Requires the 'glmnet' package to be installed
#' # rsa_mod_nneg <- rsa_model(mvpa_data, rdes, regtype="lm",
#' #                          nneg = list(dismat2 = TRUE))
#'
#' # Create an RSA model using 'lm' but returning semi-partial correlations:
#' rsa_mod_sp <- rsa_model(mvpa_data, rdes, regtype="lm",
#'                         semipartial = TRUE)
#'
#' # Train the model
#' fit_params <- train_model(rsa_mod_sp, mvpa_data$train_data)
#' # 'fit_params' = named vector of semi-partial correlations for each predictor
#'
#' @export
rsa_model <- function(dataset, 
                      design, 
                      distmethod = "spearman", 
                      regtype = "pearson", 
                      check_collinearity = TRUE,
                      nneg = NULL,
                      semipartial = FALSE) {
  
  assert_that(inherits(dataset, "mvpa_dataset"))
  assert_that(inherits(design, "rsa_design"))
  
  distmethod <- match.arg(distmethod, c("pearson", "spearman"))
  regtype    <- match.arg(regtype, c("pearson", "spearman", "lm", "rfit"))
  
  # Check for glmnet if nneg constraints are provided
  if (!is.null(nneg) && length(nneg) > 0 && regtype == "lm") {
    if (!requireNamespace("glmnet", quietly = TRUE)) {
      stop("Package 'glmnet' is required for non-negative constraints. Please install it with: install.packages('glmnet')")
    }
  }
  
  # If using LM, optionally check for collinearity
  if (regtype == "lm" && check_collinearity) {
    message("Checking design matrix for collinearity...")
    check_collinearity(design$model_mat)
    message("Collinearity check passed.")
  }
  
  # Create the RSA model object
  obj <- create_model_spec(
    "rsa_model", 
    dataset, 
    design, 
    distmethod = distmethod, 
    regtype    = regtype,
    nneg       = nneg,
    semipartial = semipartial
  )
  obj
}