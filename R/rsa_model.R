#' @noRd
#' @keywords internal
sanitize <- function(name) {
  name <- gsub(":", ".", name)
  name <- gsub(" ", "", name)
  name <- gsub("[\\(\\)]", ".", name, perl=TRUE)
  name <- gsub(",", "_", name)
  name <- gsub("\\.$", "", name)
  name
}



#' Construct a design for an RSA (Representational Similarity Analysis) model
#'
#' This function constructs a design for an RSA model using the provided formula, data, and optional parameters.
#'
#' @param formula A formula expression specifying the dissimilarity-based regression function.
#' @param data A named list containing the dissimilarity matrices and any other auxiliary variables.
#' @param block_var An optional \code{formula}, \code{character} name or \code{integer} vector designating the block structure.
#' @param split_by An optional \code{formula} indicating grouping structure for evaluating test performance.
#' @param keep_intra_run A \code{logical} indicating whether to include within-run comparisons (default: FALSE).
#' @return A list with class attributes "rsa_design" and "list", containing:
#'   \describe{
#'     \item{formula}{The input formula}
#'     \item{data}{The input data}
#'     \item{split_by}{The split_by formula}
#'     \item{split_groups}{Grouping structure for split_by}
#'     \item{block_var}{Block structure}
#'     \item{include}{Logical vector for including/excluding comparisons}
#'     \item{model_mat}{Model matrix generated by rsa_model_mat}
#'   }
#' @details
#' The function creates an RSA design based on the input parameters. It checks the validity of the input data and
#' handles splitting conditions for evaluation of test performance. It also processes optional block structures and
#' within-run comparisons.
#' @importFrom assertthat assert_that
#' @export
#' @examples
#' dismat <- dist(matrix(rnorm(100*100), 100, 100))
#' rdes <- rsa_design(~ dismat, list(dismat=dismat))
rsa_design <- function(formula, data, block_var=NULL, split_by=NULL, keep_intra_run=FALSE) {
  assert_that(purrr::is_formula(formula))
  
  # Check that all variables are either matrices, "dist", or vectors
  nr <- sapply(data, function(x) {
    if (is.matrix(x)) {
      nrow(x)
    } else if (inherits(x, "dist")) {
      attr(x, "Size")
    } else if (is.vector(x)) {
      length(x)
    } else {
      stop(paste("illegal variable type", class(x)))
    }
  })
  
  assert_that(all(nr == nr[1]), msg="all elements in 'data' must have the same number of rows")
  
  check_split <- function(split_var) {
    minSplits <- min(table(split_var))
    if (minSplits < 3) {
      stop(paste("error: splitting condition results in fewer than 3 observations in at least one set"))
    }
  }
  
  # Create split groups if split_by is provided
  split_groups <- if (!is.null(split_by)) {
    split_var <- parse_variable(split_by, data)
    split(seq_along(split_var), split_var)
  }
  
  # Process block_var if provided
  block_var <- if (!is.null(block_var)) {
    parse_variable(block_var, data)
  }
  
  # Include/exclude within-run comparisons based on keep_intra_run
  include <- if (!is.null(block_var) && !keep_intra_run) {
    as.vector(dist(block_var)) != 0
  }
  
  # Create the RSA design as a list
  des <- list(
    formula=formula,
    data=data,
    split_by=split_by,
    split_groups=split_groups,
    block_var=block_var,
    include=include
  )
  
  # Add model matrix to the design list
  mmat <- rsa_model_mat(des)
  des$model_mat <- mmat
  
  # Set the class attributes
  class(des) <- c("rsa_design", "list")
  
  # Return the RSA design
  des
}


#' Construct a model matrix for an RSA (Representational Similarity Analysis) design
#'
#' This function constructs a model matrix for the given RSA design by processing distance matrices and other variables.
#'
#' @param rsa_des An RSA design object created by \code{rsa_design()}, containing formula, data, and optional parameters.
#' @return A named list of vectors, where:
#'   \itemize{
#'     \item Names correspond to sanitized variable names from the formula
#'     \item Each vector is the processed version of the corresponding input data
#'     \item For distance matrices, only the lower triangle is included
#'     \item If rsa_des$include is specified, vectors are subset accordingly
#'   }
#' @details
#' The function takes an RSA design object as input and processes the distance matrices and other variables to
#' construct a model matrix. It handles different types of input matrices, including symmetric and asymmetric
#' distance matrices, and can include or exclude within-run comparisons based on the RSA design.
#' @examples
#' dismat <- dist(matrix(rnorm(100*100), 100, 100))
#' rdes <- rsa_design(~ dismat, list(dismat=dismat))
#' rsa_model_mat(rdes)
#' @keywords internal
#' @noRd
rsa_model_mat <- function(rsa_des) {
  rvars <- labels(terms(rsa_des$formula))
  denv <- list2env(rsa_des$data)
  vset <- lapply(rvars, function(x) eval(parse(text=x), denv))
  
  # Process input variables to create vectors from distance matrices
  vmatlist <- lapply(vset, function(v) {
    if (inherits(v, "dist")) {
      # An distance matrix of class "dist"
      as.vector(v)
    } else if (isSymmetric(v)) {
      # A full distance matrix
      v[lower.tri(v)]
    } else {
      as.vector(dist(v))
    }
  })
  
  # Include or exclude within-run comparisons based on rsa_des$include
  if (!is.null(rsa_des$include)) {
    vmatlist <- lapply(vmatlist, function(v) v[rsa_des$include])
  }
  
  # Assign sanitized names to the output list
  names(vmatlist) <- sanitize(rvars)
  
  # Return the model matrix as a named list of vectors
  vmatlist
}


#' Construct an RSA (Representational Similarity Analysis) model
#'
#' This function creates an RSA model object by taking an MVPA (Multi-Variate Pattern Analysis) dataset and an RSA design.
#'
#' @param dataset An instance of an \code{mvpa_dataset}.
#' @param design An instance of an \code{rsa_design} created by \code{rsa_design()}.
#' @param distmethod A character string specifying the method used to compute distances between observations. One of: \code{"pearson"} or \code{"spearman"} (defaults to "spearman").
#' @param regtype A character string specifying the analysis method. One of: \code{"pearson"}, \code{"spearman"}, \code{"lm"}, or \code{"rfit"} (defaults to "pearson").
#' @return A list with two elements: \code{dataset} and \code{design}, with the class attribute set to \code{"rsa_model"} and \code{"list"}.
#' @examples
#' # Create a random MVPA dataset
#' data <- matrix(rnorm(100 * 100), 100, 100)
#' labels <- factor(rep(1:2, each = 50))
#' mvpa_data <- mvpa_dataset(data, labels)
#'
#' # Create an RSA design
#' dismat <- dist(data)
#' rdes <- rsa_design(~ dismat, list(dismat = dismat))
#'
#' # Create an RSA model with default parameters
#' rsa_mod <- rsa_model(mvpa_data, rdes)
#'
#' # Create an RSA model with custom parameters
#' rsa_mod_custom <- rsa_model(mvpa_data, rdes, distmethod = "pearson", regtype = "lm")
#' @export
rsa_model <- function(dataset, design, distmethod = "spearman", regtype = "pearson") {
  assert_that(inherits(dataset, "mvpa_dataset"))
  assert_that(inherits(design, "rsa_design"))
  
  distmethod <- match.arg(distmethod, c("pearson", "spearman"))
  regtype <- match.arg(regtype, c("pearson", "spearman", "lm", "rfit"))
  
  create_model_spec("rsa_model", dataset, design, distmethod = distmethod,
                    regtype = regtype)
}



#' @keywords internal
#' @importFrom Rfit rfit
#' @noRd
run_rfit <- function(dvec, obj) {
  form <- paste("dvec", "~", paste(names(obj$design$model_mat), collapse = " + "))
  obj$design$model_mat$dvec <- dvec
  res <- Rfit::rfit(form, data=obj$design$model_mat)
  coef(res)[-1]
}


#' @keywords internal
#' @importFrom stats coef cor dist rnorm terms lm sd
#' @noRd
run_lm <- function(dvec, obj) {
  form <- paste("dvec", "~", paste(names(obj$design$model_mat), collapse = " + "))
  vnames <- names(obj$design$model_mat)
  obj$design$model_mat$dvec <- dvec
  res <- lm(form, data=obj$design$model_mat)
  res <- coef(summary(res))[-1,3]
  names(res) <- vnames
  res
}

#' @keywords internal
#' @noRd
run_cor <- function(dvec, obj) {
  res <- sapply(obj$design$model_mat, function(x) cor(dvec, x, method=obj$distmethod))
  names(res) <- names(obj$design$model_mat)
  res
}

#' Train an RSA Model
#'
#' This function trains an RSA (representational similarity analysis) model using the specified method and distance calculation.
#'
#' @param obj An object of class \code{rsa_model}.
#' @param train_dat The training data.
#' @param indices The indices of the training data.
#' @param ... Additional arguments passed to the training method.
#' @return The trained model.
#' @export
train_model.rsa_model <- function(obj, train_dat, indices, ...) {
  dtrain <- 1 - cor(t(train_dat), method=obj$distmethod)
  dvec <- dtrain[lower.tri(dtrain)]
  
  if (!is.null(obj$design$include)) {
    dvec <- dvec[obj$design$include]
  }
  
  switch(obj$regtype,
         rfit=run_rfit(dvec, obj),
         lm=run_lm(dvec,obj),
         pearson=run_cor(dvec,obj),
         spearman=run_cor(dvec,obj))
  
}

#' @export
# process_roi.rsa_model <- function( mod_spec, roi, rnum,...) {
#   xtrain <- tibble::as_tibble(neuroim2::values(roi$train_roi), .name_repair=.name_repair)
#   ind <- indices(roi$train_roi)
#   ret <- try(train_model(mod_spec, xtrain, ind))
#   if (inherits(ret, "try-error")) {
#     tibble::tibble(result=list(NULL), indices=list(ind), performance=list(ret), id=rnum, error=TRUE, error_message=attr(ret, "condition")$message)
#   } else {
#     tibble::tibble(result=list(NULL), indices=list(ind), performance=list(ret), id=rnum, error=FALSE, error_message="~")
#   }
# }

#' @export
#' @method print rsa_model
print.rsa_model <- function(x, ...) {
  # Ensure crayon is available
  if (!requireNamespace("crayon", quietly = TRUE)) {
    stop("Package 'crayon' is required for pretty printing. Please install it.")
  }
  
  # Define color scheme
  header_style <- crayon::bold$cyan
  section_style <- crayon::yellow
  info_style <- crayon::white
  number_style <- crayon::green
  method_style <- crayon::magenta
  formula_style <- crayon::italic$blue
  
  # Print header
  cat("\n", header_style("█▀▀ RSA Model ▀▀█"), "\n\n")
  
  # Model configuration
  cat(section_style("├─ Configuration"), "\n")
  cat(info_style("│  ├─ Distance Method: "), method_style(x$distmethod), "\n")
  cat(info_style("│  └─ Regression Type: "), method_style(x$regtype), "\n")
  
  # Dataset information
  cat(section_style("├─ Dataset"), "\n")
  dims <- dim(x$dataset$train_data)
  dim_str <- paste0(paste(dims[-length(dims)], collapse=" × "), 
                   " × ", number_style(dims[length(dims)]), " observations")
  cat(info_style("│  ├─ Dimensions: "), dim_str, "\n")
  cat(info_style("│  └─ Type: "), class(x$dataset$train_data)[1], "\n")
  
  # Design information
  cat(section_style("├─ Design"), "\n")
  cat(info_style("│  ├─ Formula: "), formula_style(deparse(x$design$formula)), "\n")
  
  # Variables in model matrix
  var_names <- names(x$design$model_mat)
  cat(info_style("│  └─ Predictors: "), method_style(paste(var_names, collapse=", ")), "\n")
  
  # Structure information
  cat(section_style("└─ Structure"), "\n")
  
  # Block information
  if (!is.null(x$design$block_var)) {
    blocks <- table(x$design$block_var)
    cat(info_style("   ├─ Blocking: "), "Present\n")
    cat(info_style("   ├─ Number of Blocks: "), number_style(length(blocks)), "\n")
    cat(info_style("   ├─ Mean Block Size: "), 
        number_style(format(mean(blocks), digits=2)),
        crayon::italic$white(" (SD: "),
        number_style(format(sd(blocks), digits=2)),
        crayon::italic$white(")"), "\n")
  } else {
    cat(info_style("   ├─ Blocking: "), crayon::red("None"), "\n")
  }
  
  # Split information
  if (!is.null(x$design$split_by)) {
    split_info <- length(x$design$split_groups)
    cat(info_style("   └─ Split Groups: "), number_style(split_info), "\n")
  } else {
    cat(info_style("   └─ Split Groups: "), crayon::red("None"), "\n")
  }
  
  cat("\n")
}

#' @export
#' @method print rsa_design
print.rsa_design <- function(x, ...) {
  # Ensure crayon is available
  if (!requireNamespace("crayon", quietly = TRUE)) {
    stop("Package 'crayon' is required for pretty printing. Please install it.")
  }
  
  # Define color scheme
  header_style <- crayon::bold$cyan
  section_style <- crayon::yellow
  info_style <- crayon::white
  number_style <- crayon::green
  formula_style <- crayon::italic$blue
  var_style <- crayon::magenta
  
  # Print header
  cat("\n", header_style("█▀▀ RSA Design ▀▀█"), "\n\n")
  
  # Formula section
  cat(section_style("├─ Formula"), "\n")
  cat(info_style("│  └─ "), formula_style(deparse(x$formula)), "\n")
  
  # Data section
  cat(section_style("├─ Variables"), "\n")
  var_types <- sapply(x$data, function(v) {
    if (inherits(v, "dist")) "distance matrix"
    else if (is.matrix(v)) "matrix"
    else if (is.vector(v)) "vector"
    else "other"
  })
  
  cat(info_style("│  ├─ Total Variables: "), number_style(length(x$data)), "\n")
  for (i in seq_along(x$data)) {
    prefix <- if (i == length(x$data)) "└" else "├"
    cat(info_style(sprintf("│  %s─ ", prefix)), 
        var_style(names(x$data)[i]), ": ", 
        number_style(var_types[i]), "\n")
  }
  
  # Structure section
  cat(section_style("└─ Structure"), "\n")
  
  # Block information
  if (!is.null(x$block_var)) {
    blocks <- table(x$block_var)
    cat(info_style("   ├─ Blocking: "), "Present\n")
    cat(info_style("   ├─ Number of Blocks: "), number_style(length(blocks)), "\n")
    cat(info_style("   ├─ Block Sizes: "), 
        number_style(paste0(names(blocks), ": ", blocks, collapse=", ")), "\n")
  } else {
    cat(info_style("   ├─ Blocking: "), crayon::red("None"), "\n")
  }
  
  # Include/exclude information
  if (!is.null(x$include)) {
    n_comparisons <- length(x$include)
    n_included <- sum(x$include)
    cat(info_style("   └─ Comparisons: "), 
        number_style(n_included), 
        crayon::italic$white(" of "), 
        number_style(n_comparisons), 
        crayon::italic$white(sprintf(" (%.1f%%)", 100*n_included/n_comparisons)), "\n")
  } else {
    cat(info_style("   └─ Comparisons: "), "All included\n")
  }
  
  cat("\n")
}





