% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mvpa_model.R
\name{mvpa_model}
\alias{mvpa_model}
\title{Create an MVPA Model}
\usage{
mvpa_model(
  model,
  dataset,
  design,
  model_type = c("classification", "regression"),
  crossval = NULL,
  feature_selector = NULL,
  tune_grid = NULL,
  tune_reps = 15,
  performance = NULL,
  class_metrics = TRUE,
  compute_performance = TRUE,
  return_predictions = TRUE,
  return_fits = FALSE
)
}
\arguments{
\item{model}{A character string naming a model from the MVPAModels registry, or a custom model specification list.}

\item{dataset}{An `mvpa_dataset` instance.}

\item{design}{An `mvpa_design` instance.}

\item{model_type}{A character string indicating the problem type: "classification" or "regression".}

\item{crossval}{An optional `cross_validation` instance.}

\item{feature_selector}{An optional `feature_selector` instance.}

\item{tune_grid}{An optional parameter tuning grid as a `data.frame`.}

\item{tune_reps}{The number of replications used during parameter tuning. Only relevant if `tune_grid` is supplied.}

\item{performance}{An optional custom function for computing performance metrics.}

\item{class_metrics}{A logical flag indicating whether to compute performance metrics for each class.}

\item{compute_performance}{A \code{logical} indicating whether to compute and store performance measures for each voxel set (defaults to TRUE).}

\item{return_predictions}{A \code{logical} indicating whether to return row-wise predictions for each voxel set (defaults to TRUE).}

\item{return_fits}{A \code{logical} indicating whether to return the model fit for each voxel set (defaults to FALSE).}
}
\description{
Create an MVPA model based on a classification or regression model from the MVPAModels registry.
}
\details{
If `performance` is supplied, it must be a function that takes one argument and returns a named list of scalar values. 
The argument the function takes is a class deriving from `classification_result` appropriate for the problem at hand.
See example below.
}
\examples{

mod <- load_model("sda")
arr_data <- array(rnorm(6*6*6*100), c(6,6,6,100))
sp <- neuroim2::NeuroSpace(c(6,6,6,100))
traindat <- neuroim2::NeuroVec(arr_data, sp)
mask <- neuroim2::LogicalNeuroVol(array(rnorm(6*6*6)>-.2, c(6,6,6)), neuroim2::NeuroSpace(c(6,6,6)))

mvdset <- mvpa_dataset(traindat,mask=mask)
design <- data.frame(fac=rep(letters[1:4], 25), block=rep(1:10, each=10))
cval <- blocked_cross_validation(design$block)
mvdes <- mvpa_design(design, ~ fac, block_var=~block)

custom_perf <- function(result) {
  c(accuracy=sum(result$observed == result$predicted)/length(result$observed))
}
mvpmod <- mvpa_model(mod, dataset=mvdset, design=mvdes, crossval=cval, performance=custom_perf)
ret <- run_searchlight(mvpmod)
stopifnot("accuracy" \%in\% names(ret))
}
