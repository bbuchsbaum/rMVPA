% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/allgeneric.R, R/regional.R
\name{run_regional}
\alias{run_regional}
\alias{run_regional_base}
\alias{run_regional.default}
\alias{run_regional.mvpa_model}
\alias{run_regional.rsa_model}
\alias{run_regional.vector_rsa_model}
\title{Region of Interest Based MVPA Analysis}
\usage{
run_regional(model_spec, region_mask, ...)

run_regional_base(
  model_spec,
  region_mask,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  compute_performance = model_spec$compute_performance,
  return_predictions = model_spec$return_predictions,
  return_fits = model_spec$return_fits,
  ...
)

\method{run_regional}{default}(model_spec, region_mask, ...)

\method{run_regional}{mvpa_model}(
  model_spec,
  region_mask,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  ...
)

\method{run_regional}{rsa_model}(
  model_spec,
  region_mask,
  return_fits = FALSE,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  ...
)

\method{run_regional}{vector_rsa_model}(
  model_spec,
  region_mask,
  return_fits = FALSE,
  compute_performance = TRUE,
  coalesce_design_vars = FALSE,
  processor = NULL,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{model_spec}{A \code{mvpa_model} instance containing the model specifications}

\item{region_mask}{A \code{NeuroVol} or \code{NeuroSurface} object where each region is identified by a unique integer}

\item{...}{Extra arguments passed to specific regional analysis methods (e.g., `return_fits`, `compute_performance`).}

\item{coalesce_design_vars}{If \code{TRUE}, merges design variables into the prediction table (if present and generated). Default is \code{FALSE}.}

\item{processor}{An optional custom processor function for each region (ROI). If NULL (default), behavior depends on the \code{model_spec} class.}

\item{verbose}{If \code{TRUE}, print progress messages during iteration (default is \code{FALSE}).}

\item{compute_performance}{Logical indicating whether to compute performance metrics (default \code{TRUE}).}

\item{return_predictions}{Logical indicating whether to combine a full prediction table (defaults to \code{model_spec$return_predictions}).}

\item{return_fits}{Logical indicating whether to return the fitted models (default \code{FALSE}).}
}
\value{
A \code{regional_mvpa_result} object (list) containing:
  \item{performance_table}{A tibble of performance metrics for each region (if computed).}
  \item{prediction_table}{A tibble with detailed predictions for each observation/region (if generated).}
  \item{vol_results}{A list of volumetric maps representing performance metrics across space (if computed).}
  \item{fits}{A list of fitted model objects for each region (if requested via `return_fits=TRUE`).}
  \item{model_spec}{The original model specification object provided.} # Note: Original documentation said 'performance', clarified here.
}
\description{
Run a separate MVPA analysis for multiple disjoint regions of interest.
}
\details{
This function serves as the base implementation for regional analyses, orchestrating data preparation, iteration over regions, performance computation, and result aggregation. Specific `run_regional` methods for different model classes may call this function or provide specialized behavior.

This is the fallback method called when no specialized `run_regional` method is found for the class of `model_spec`. It typically calls `run_regional_base`.

This method provides the standard regional analysis pipeline for objects of class `mvpa_model` by calling `run_regional_base`.

For `rsa_model` objects, `return_predictions` defaults to `FALSE` as standard RSA typically doesn't produce a prediction table in the same way as classification/regression models.

For `vector_rsa_model` objects, `return_predictions` defaults to `FALSE` in `run_regional_base`.
If `model_spec$return_predictions` is TRUE, this method will assemble an `observation_scores_table`.
}
\examples{
\donttest{
  # Generate sample dataset (3D volume with categorical response)
  dataset <- gen_sample_dataset(
    D = c(10,10,10),       # Small 10x10x10 volume
    nobs = 100,            # 100 observations
    nlevels = 3,           # 3 classes
    response_type = "categorical",
    data_mode = "image",
    blocks = 3             # 3 blocks for cross-validation
  )
  
  # Create region mask with 5 ROIs
  region_mask <- NeuroVol(
    sample(1:5, size=length(dataset$dataset$mask), replace=TRUE),
    space(dataset$dataset$mask)
  )
  
  # Create cross-validation specification
  cval <- blocked_cross_validation(dataset$design$block_var)
  
  # Load SDA classifier (Shrinkage Discriminant Analysis)
  model <- load_model("sda_notune")
  
  # Create MVPA model
  mspec <- mvpa_model(
    model = model,
    dataset = dataset$dataset,
    design = dataset$design,
    model_type = "classification",
    crossval = cval,
    return_fits = TRUE    # Return fitted models
  )
  
  # Run regional analysis
  results <- run_regional(mspec, region_mask)
  
  # Access results
  head(results$performance)           # Performance metrics
  head(results$prediction_table)      # Predictions
  first_roi_fit <- results$fits[[1]]  # First ROI's fitted model
}

}
