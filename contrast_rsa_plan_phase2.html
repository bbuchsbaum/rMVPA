<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Contrast RSA / MS-ReVE Phase 2 Implementation Plan • rMVPA</title><script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="deps/headroom-0.11.0/headroom.min.js"></script><script src="deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="deps/search-1.0.0/fuse.min.js"></script><script src="deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="Contrast RSA / MS-ReVE Phase 2 Implementation Plan"></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="index.html">rMVPA</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.2</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="articles/index.html">Articles</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-title-body">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Contrast RSA / MS-ReVE Phase 2 Implementation Plan</h1>

    </div>

<div id="contrast-rsa--ms-reve-phase-2-implementation-plan" class="section level1">

<p>This document outlines the features and refinements to be added to the <code>contrast_rsa_model</code> functionality based on the original proposal (<code>signed_rsa_proposal.md</code>) and the current implementation state.</p>
<p>Keep things modular and simple! No God functions! No functions more than 100 lines!</p>
<p>** always check off checkboxes when done **</p>
<div class="section level2">
<h2 id="core-engine-enhancements-section-c-of-proposal">Core Engine Enhancements (Section C of Proposal)<a class="anchor" aria-label="anchor" href="#core-engine-enhancements-section-c-of-proposal"></a></h2>
<ul class="task-list"><li><label><input type="checkbox" checked><strong>Advanced Û Estimation (C.1):</strong> Implemented <code>"L2_norm"</code> and <code>"crossnobis"</code> (requiring user-supplied whitening matrix <code>W</code>) options in <code>compute_crossvalidated_means_sl</code>. (Further methods like internal Σ estimation for crossnobis from betas could be future enhancements if needed, but current implementation relies on pre-computed <code>W</code> derived from GLM residuals as per best practice).</label></li>
<li><label><input type="checkbox" checked><strong>RSA Regularization (C.3):</strong> Implement regularization options (<code>"ridge_hkb"</code> added for Hoerl-Kennard-Baldwin lambda). (Further options like GCV, fixed lambda, or elastic-net still pending for future enhancement).</label></li>
<li><label><input type="checkbox" checked><strong>RSA Collinearity Check (C.3):</strong> Implement the <code>check_collinearity=TRUE</code> functionality in the <code>contrast_rsa_model</code> constructor to check the rank of the contrast RDM predictor matrix (<code>Xmat</code>).</label></li>
<li><label><input type="checkbox" checked><strong>Normalized Δ_q Contributions (C.4):</strong> Add an option (<code>normalize_delta</code> parameter in <code>contrast_rsa_model</code>) to calculate and potentially use normalized voxel contributions (<code>~Δ_q = Δ_q / ||Δ_q||</code>).</label></li>
</ul></div>
<div class="section level2">
<h2 id="voxel-level-refinements-section-d-of-proposal">Voxel-Level Refinements (Section D of Proposal)<a class="anchor" aria-label="anchor" href="#voxel-level-refinements-section-d-of-proposal"></a></h2>
<ul class="task-list"><li>
<p><label><input type="checkbox"><strong>Voxel Reliability Weighting (ρ_q,v) (D.1):</strong> Implement the calculation of voxel contribution reliability across cross-validation folds within <code>train_model.contrast_rsa_model</code>. This requires storing fold-specific <code>U_hat_sl</code> or <code>Delta_sl</code>.</label></p>
<blockquote>
<p><strong>Context: Why Voxel Reliability (ρ_q,v)?</strong></p>
<p>The <code>β · Δ</code> map answers: <em>What direction and how strongly does voxel v contribute to contrast q on average within this searchlight?</em></p>
<p>Reliability (ρ_q,v) answers the follow-up: <em>Is that contribution repeatable across different subsets of the data (folds)?</em></p>
<p><strong>Intuition:</strong> If Δ_q,v jumps wildly from fold to fold, it’s likely driven by noise. ρ scales from 0 (unreliable) to 1 (perfectly stable).</p>
<p><strong>Formula:</strong> [ _{q,v} = 1 -  ]</p>
<ul><li>Numerator: Empirical fold-to-fold variance of the voxel’s contribution.</li>
<li>Denominator: Adds expected noise variance (σ²_noise) to prevent over-penalizing stable signals measured with limited data.</li>
</ul><p><strong>Noise Variance Estimation (σ²_noise,q,v):</strong> This represents the expected variance of Δ_q,v if the true signal were zero. It’s derived from within-condition residual variances (σ²_k,v(s)) estimated from the noise whitening/pre-processing stage, weighted by the contrast weights (w_qk) and the number of trials (n_k(s)) per condition k in fold s: [ ^2_{,q,v} =  <em>{s=1}^{S} </em>{k=1}^{K}  _{k,v}^{2(s)} ] (This requires access to within-condition residual variances, which might need to be passed through or estimated differently depending on the exact preprocessing pipeline, e.g., if using GLM residuals).</p>
<p><strong>Practical Use:</strong> Generate reliability-weighted maps: [ M^{}<em>{q,v} = </em>{q,v} ; <em>q , </em>{q,v} ]</p>
</blockquote>
<blockquote>
<p><strong>Context: Implementation Cost &amp; Strategies for ρ_q,v</strong></p>
<p><strong>Challenge:</strong> Storing Δ_q,v for every fold (S), contrast (Q), voxel (V) in every searchlight (#SL) can consume significant RAM (e.g., S × Q × V × #SL × 8 bytes).</p>
<strong>Cost-Saving Strategies:</strong>
<ol style="list-style-type: decimal"><li>
<strong>On-the-fly Welford variance:</strong> Update the running mean and sum of squared differences (M2) for Δ_q,v as each fold’s Δ_fold arrives. Discard Δ_fold afterwards. Requires only O(Q × V) memory buffer per searchlight. <code>R     # Pseudo-R for Welford inside sphere loop     # Needs mean_D, m2_D (both QxV) initialized     delta &lt;- Delta_fold - mean_D     mean_D &lt;- mean_D + delta / fold_id     m2_D &lt;- m2_D + delta * (Delta_fold - mean_D)     # After loop: var_D &lt;- m2_D / (S - 1)</code>
</li>
<li>
<strong>Center-voxel only:</strong> Compute and store ρ_q,v only for the center voxel of the searchlight. Reliability information gets implicitly smoothed across the brain by overlapping searchlights.</li>
<li>
<strong>Split-half reliability (S=2):</strong> If using only two folds (e.g., odd vs. even runs), variance is analytic: Var = (Δ₁ - Δ₂)² / 4. Matches Walther et al. (2016) approach. Coarser but very cheap.</li>
<li>
<strong>Jack-knife (Leave-One-Run-Out, S &gt;= 3):</strong> Recompute Δ leaving out run s (Δ_(-s)). Variance is computed from these S pseudo-values. Requires minimal extra buffering if Δ_(-s) is recomputed on demand. <code>jack_var = (S-1)/S * sum( (Delta_neg_s - mean(Delta_neg_s))^2 )</code>
</li>
<li>
<strong>Bootstrap (Fold-level Resampling, S &gt;= 3):</strong> Sample S folds with replacement B times (e.g., B=100). Compute variance of Δ across bootstrap samples. CPU scales with B, but uses pre-computed per-fold Δ (if stored/cached) or recomputes on the fly.</li>
</ol><p><strong>Recommendation:</strong> Welford or Jack-knife offer good precision with low memory overhead for S &gt;= 3. Split-half is viable for S=2 or when coarse reliability is sufficient.</p>
</blockquote>
<p><!-- FUTURE IMPLEMENTATION NOTES FOR RELIABILITY (ρ_q,v) --></p>
<details><summary><p><strong>[Future Plan] Detailed Implementation Notes for Reliability (ρ_q,v)</strong></p>
</summary><p>Based on the discussion on implementation efficiency and the blueprint provided:</p>
<p><strong>Guiding Principles:</strong></p>
<ol style="list-style-type: decimal"><li>Avoid modifying <code>compute_crossvalidated_means_sl</code> to return fold-wise data.</li>
<li>Compute fold-specific Δ (<code>Delta_fold_sl</code>) on-the-fly within <code>train_model.contrast_rsa_model</code>.</li>
<li>Use Welford’s online algorithm for variance calculation to minimize memory.</li>
<li>Gate the feature behind a <code>calc_reliability</code> flag in the <code>contrast_rsa_model</code> constructor (defaulting to <code>FALSE</code>).</li>
</ol><p><strong>Proposed <code>rho</code> Formula:</strong> Use the ICC-like form <code>rho = sigma2_noise_param / (var_delta + sigma2_noise_param)</code> where <code>sigma2_noise_param = (S-1) * var_delta</code> for <code>S &gt; 1</code> (number of folds). This simplifies to <code>rho = (S-1)/S</code> for <code>var_delta &gt; 0</code>. Handle edge cases:</p>
<ul><li>
<p>If <code>var_delta = 0</code> (perfect stability), <code>rho = 1</code>.</p>
<ul><li>If <code>S = 1</code>, <code>rho = 0</code> (unless <code>var_delta = 0</code>, then <code>rho = 1</code>).</li>
</ul><p><strong>Implementation Steps:</strong></p>
<p><strong>1. <code>contrast_rsa_model</code> Constructor (<code>R/contrast_rsa_model.R</code>):</strong> * Add <code>calc_reliability = FALSE</code> parameter. * Store in model spec via <code>create_model_spec</code>. * Update Roxygen docs.</p>
<p><strong>2. <code>train_model.contrast_rsa_model</code> (<code>R/contrast_rsa_model.R</code>):</strong> * Initialize <code>rho_vc_sl = rep(1, Q)</code> (default: neutral weight). * <strong>If <code>obj$calc_reliability</code> is <code>TRUE</code>:</strong> * Get <code>S = get_nfolds(cv_spec)</code>. * Get <code>C</code>, <code>V_sl</code>, <code>Q</code>, <code>mvpa_des</code>. * Initialize Welford accumulators: <code>m_Delta_sl = matrix(0, V_sl, Q)</code>, <code>M2_Delta_sl = matrix(0, V_sl, Q)</code>. * Loop <code>s_idx</code> from 1 to <code>S</code>: * Get <code>train_indices_fold_s</code>. * Handle empty/problematic folds (skip or ensure NA propagation). * Compute <code>U_hat_sl_fold_s</code> (K x V_sl) using logic similar to <code>compute_cv_means</code> (subsetting <code>sl_data</code>, <code>aggregate</code>, re-indexing, handling missing conditions -&gt; NAs). * If <code>anyNA(U_hat_sl_fold_s)</code>, skip Welford update for this fold or ensure NAs propagate correctly. * <code>Delta_fold_sl = t(U_hat_sl_fold_s) %*% C</code> (V_sl x Q). * Perform Welford update on <code>m_Delta_sl</code> and <code>M2_Delta_sl</code> using <code>Delta_fold_sl</code>. * After loop (let <code>S_eff</code> be number of valid folds processed): * Initialize <code>rho_sl = matrix(0, V_sl, Q)</code>. * If <code>S_eff &gt; 1</code>: * <code>var_Delta_sl = M2_Delta_sl / (S_eff - 1)</code>. * <code>sigma2_noise_param_sl = (S_eff - 1) * var_Delta_sl</code>. * <code>denominator_rho = var_Delta_sl + sigma2_noise_param_sl</code>. * <code>rho_sl = sigma2_noise_param_sl / denominator_rho</code>. * Handle <code>denominator_rho &lt; 1e-10</code> (set <code>rho_sl = 1</code>). * Handle <code>NA</code> values in <code>rho_sl</code> (set <code>rho_sl = 0</code>). * Else if <code>S_eff == 1</code>: * Handle perfect stability case: <code>rho_sl[M2_Delta_sl == 0] = 1</code>. * Extract <code>rho_vc_sl = rho_sl[center_idx, , drop = TRUE]</code>. * Modify final metric calculation: <code>R         final_delta_vc_sl = delta_vc_sl # Potentially normalized delta         if (obj$output_metric == "beta_delta") {             # Apply reliability weight             result_vector &lt;- beta_sl * final_delta_vc_sl * rho_vc_sl          } else if (obj$output_metric == "delta_only") {             # Keep raw (potentially normalized) delta? Or apply rho?             # Decision needed: For now, keep as is.             result_vector &lt;- final_delta_vc_sl          } else { # beta_only             result_vector &lt;- beta_sl         }</code></p>
</li></ul></details><!-- END FUTURE IMPLEMENTATION NOTES --></li>
</ul><li>
<p><label><input type="checkbox" checked><strong>Voxel-Specific RDM Reconstruction (r_v) (D.2):</strong> Implement the calculation of the voxel-specific RDM reconstruction score (<code>r_v</code>) as the <code>"recon_score"</code> output metric.</label></p>
<blockquote>
<p><strong>Context: Why Voxel Reconstruction Score (r_v)?</strong></p>
<p>This metric answers: <em>How much does this single voxel v, with its specific profile of contributions across all contrasts Q, matter for reproducing the overall representational geometry (Ĝ_empirical) observed in this searchlight?</em></p>
<p><strong>Intuition:</strong> It’s a “leave-one-voxel-in” score. If r_v ≈ 1, this single voxel carries much of the information about pairwise condition distances relevant to the contrasts. If r_v ≈ 0, the geometry relies on the pattern across <em>other</em> voxels.</p>
<p><strong>Building the One-Voxel Model RDM (Ĝ^(v)):</strong> Use the voxel’s signed contributions (Δ_q,v) scaled by the overall contrast importance (β_q) for the searchlight. Project this Q-dimensional profile back into the KxK condition space using the contrast matrix C: [ ^{(v)} = C ; (<em>1 </em>{1,v}, , <em>Q </em>{Q,v}) ; C^T ]</p>
<p><strong>Calculating the Score (r_v):</strong> Correlate the vectorized lower triangle of the one-voxel RDM (Ĝ^(v)) with the vectorized lower triangle of the empirical RDM (Ĝ_empirical) from the searchlight: [ r_v = ( <em>{}(^{(v)}), ; </em>{}(_{}) ) ]</p>
<p><strong>Interpretation:</strong> A map of r_v (or |r_v|) highlights voxels that are individually highly informative about the multi-contrast representational structure.</p>
<p><strong>Implementation Cost:</strong> Very low. Requires C, β_q, Δ_q,v, and vec(Ĝ_empirical), most of which are already computed. The matrix multiplications per voxel are small (KxQ, QxQ, QxK). The correlation is between two vectors of length K(K-1)/2.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Pseudo-R for r_v inside sphere loop, after beta &amp; Delta computed</span></span>
<span><span class="va">y_emp</span> <span class="op">&lt;-</span> <span class="fu">lower</span><span class="op">(</span><span class="va">G_hat_empirical</span><span class="op">)</span> <span class="co"># Precompute</span></span>
<span><span class="va">beta_diag</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">beta</span><span class="op">)</span>         <span class="co"># QxQ</span></span>
<span><span class="va">r_v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">numeric</a></span><span class="op">(</span><span class="va">V</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">v</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">V</span><span class="op">)</span> <span class="op">{</span></span>
<span>   <span class="co"># Delta is V x Q or Q x V depending on implementation</span></span>
<span>   <span class="co"># Assuming Delta is V x Q here:</span></span>
<span>   <span class="va">voxel_loading_diag</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">beta</span> <span class="op">*</span> <span class="va">Delta</span><span class="op">[</span><span class="va">v</span>, <span class="op">]</span><span class="op">)</span> <span class="co"># Corrected: element-wise product</span></span>
<span>   <span class="va">G_hat_v</span> <span class="op">&lt;-</span> <span class="va">C</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">voxel_loading_diag</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">C</span><span class="op">)</span></span>
<span>   <span class="va">r_v</span><span class="op">[</span><span class="va">v</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">cor</a></span><span class="op">(</span><span class="fu">lower</span><span class="op">(</span><span class="va">G_hat_v</span><span class="op">)</span>, <span class="va">y_emp</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
</blockquote>
</li>

</div>
<div class="section level2">
<h2 id="additional-output-maps-section-e-of-proposal">Additional Output Maps (Section E of Proposal)<a class="anchor" aria-label="anchor" href="#additional-output-maps-section-e-of-proposal"></a></h2>
<ul class="task-list"><li><label><input type="checkbox" checked><strong>Direction-Only Maps (~M_q,v) (E.1):</strong> Add an <code>output_metric</code> option (<code>"beta_delta_norm"</code>) to <code>contrast_rsa_model</code> to generate maps based on normalized Δ_q (<code>β_q * ~Δ_{q,v}</code>).</label></li>
<li><label><input type="checkbox"><strong>Reliability-Weighted Maps (M_q,v_reliab) (E.1):</strong> Add an <code>output_metric</code> option (e.g., <code>"beta_delta_reliable"</code>) to generate maps weighted by voxel reliability (<code>ρ_{q,v} * β_q * Δ_{q,v}</code>). Requires completion of D.1.</label></li>
<li><label><input type="checkbox" checked><strong>Composite Map (w_v) (E.2):</strong> Add an <code>output_metric</code> option (<code>"composite"</code>) to calculate a composite map representing the net pull of a voxel (e.g., <code>Σ_q (β_q * ~Δ_{q,v})</code>), including orthonormality check.</label></li>
</ul></div>
<div class="section level2">
<h2 id="documentation--examples">Documentation &amp; Examples<a class="anchor" aria-label="anchor" href="#documentation--examples"></a></h2>
<ul class="task-list"><li><label><input type="checkbox"><strong>Add Examples (<code>@examples</code>):</strong> Add runnable examples to all exported functions, particularly <code><a href="reference/contrast_rsa_model.html">contrast_rsa_model()</a></code> and <code><a href="reference/run_searchlight.contrast_rsa_model.html">run_searchlight.contrast_rsa_model()</a></code>, creating necessary dummy objects.</label></li>
<li><label><input type="checkbox"><strong>Update Documentation:</strong> Ensure all new parameters and options added during Phase 2 are clearly documented.</label></li>
</ul></div>
<div class="section level2">
<h2 id="refactoring--code-quality">Refactoring &amp; Code Quality<a class="anchor" aria-label="anchor" href="#refactoring--code-quality"></a></h2>
<ul class="task-list"><li><label><input type="checkbox" checked><strong>Refactor <code>wrap_out</code>/<code>create_searchlight_performance</code>:</strong> Simplify the interaction between these functions in <code>R/searchlight.R</code>. (Done by making <code>wrap_out</code> directly create spatial objects and commenting out <code>create_searchlight_performance</code>, and adjusting <code>print.searchlight_result</code>).</label></li>
<li><label><input type="checkbox" checked><strong>Check <code>cv_spec</code> Validity:</strong> Implement the <code>TODO</code> check for <code>cv_spec</code> validity in <code>R/compute_cv_means.R</code>.</label></li>
<li><label><input type="checkbox"><strong>Verify <code>DESCRIPTION</code>:</strong> Double-check that all necessary package dependencies (<code>neuroim2</code>, <code>neurosurf</code>, <code>dplyr</code>, <code>purrr</code>, etc.) are correctly listed in the <code>Imports</code> field of the <code>DESCRIPTION</code> file.</label></li>
<li><label><input type="checkbox" checked><strong>Review Block Exclusion Logic (C4):</strong> Addressed by deriving <code>condition_block_list</code> in <code>msreve_design</code> and using it in <code>train_model.contrast_rsa_model</code>.</label></li>
<li><label><input type="checkbox" checked><strong>Replace <code>aggregate</code> with <code>rowsum</code> in <code>compute_cv_means</code> (Audit Quick Win #2):</strong> Replaced <code><a href="https://rdrr.io/r/stats/aggregate.html" class="external-link">stats::aggregate</a></code> with <code>rowsum</code> and <code>table</code> for calculating fold-wise condition means for performance.</label></li>
</ul><hr></div>
<div class="section level2">
<h2 id="appendix-context-on-interaction-effects-section-f">Appendix: Context on Interaction Effects (Section F)<a class="anchor" aria-label="anchor" href="#appendix-context-on-interaction-effects-section-f"></a></h2>
<blockquote>
<p><strong>Why Interactions Matter in RSA:</strong> Main effect contrasts test simple geometric predictions (e.g., animate vs. inanimate separation). Interactions test if the geometry has extra structure beyond the sum of main effects.</p>
<p><strong>Construction:</strong> An interaction contrast column (c_inter) is the element-wise product (⊙) of two centered main effect columns (c_p, c_q): <code>c_inter = c_p ⊙ c_q</code>.</p>
<p><strong>Interaction RDM:</strong> The model RDM for the interaction (<code>R_inter = c_inter %*% t(c_inter)</code>) predicts similarity (+1) for condition pairs sharing the same interaction sign (e.g., both are [+p, +q] or both are [-p, -q]) and dissimilarity (-1) for pairs differing in interaction sign (e.g., [+p, +q] vs. [+p, -q]). This captures a pattern orthogonal to both main effect RDMs.</p>
<p><strong>Orthogonalization:</strong> It’s crucial to orthogonalize the full contrast matrix <code>C_exp = [C_main | C_inter]</code> (e.g., using <code>rMVPA::contrasts(..., orth=TRUE)</code> or <code><a href="reference/orthogonalize_contrasts.html">rMVPA::orthogonalize_contrasts()</a></code>). This ensures that the regression coefficient β_inter reflects variance uniquely explained by the interaction term after accounting for main effects.</p>
<p><strong>Interpretation:</strong> - <code>Δ_inter,v = t(U_hat) %*% c_tilde_inter</code>: Voxel v’s projection onto the <em>orthogonalized</em> interaction contrast. - <code>β_inter * Δ_inter,v</code>: How strongly voxel v contributes <em>uniquely</em> to the interaction pattern. - Example: A voxel might respond strongly only to “animate-small” conditions, contributing positively to an animacy-by-size interaction, even if its response to animacy or size alone isn’t distinct.</p>
<p><strong>Workflow:</strong> Define interactions in the <code>spec</code> for <code><a href="reference/contrasts.html">rMVPA::contrasts()</a></code>, ensure <code>orth=TRUE</code>, then run <code>contrast_rsa_model</code>. The engine handles interaction columns like any other contrast.</p>
</blockquote>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Bradley Buchsbaum.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer></div>





  </body></html>

